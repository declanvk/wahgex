<!doctype html>
<html>

<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./favicon.svg">
    <link rel="stylesheet" href="./style.css">

    <title>WAHGEX - compiled regular expressions</title>
</head>

<body>
    <header>
        <nav>
            <ul>
                <li><a href="./index.html">Home</a></li>
                <li><a href="./playground.html">Playground</a></li>
                <li><a href="./docs.html">Docs</a></li>
            </ul>
        </nav>
        <h1>WAHGEX - Compiled regular expressions</h1>
    </header>

    <main>
        <article>
            <h2>WHAT</h2>
            <p>WAHGEX is a regular expression engine that compiles the regex into a WebAssembly (WASM) module instead of
                executing it directly. The output WASM module can be passed to a variety of engines, such as the Web
                platform, <a href="https://wasmtime.dev/" target="_blank">Wasmtime</a>, or <a
                    href="https://github.com/wasmi-labs/wasmi" target="_blank">wasmi</a>.</p>
            <p>Visit the WAHGEX <a href="./playground.html" target="_blank">playground</a> for an example application
                which uses the WASM modules to execute regex on an input haystack.</p>

            <p>This project is still a work in progress, and several features are currently missing:</p>
            <ul>
                <li>Unicode support in lookaround assertions.</li>
                <li>Reporting captures or even offsets of the overall match within the haystack.</li>
                <li>Better library integration with specific WASM engines like Wasmtime or wasmi. Currently, it requires more manual setup.</li>
                <li>Better optimization of the output WASM code.<sup><a href=" #fn1" id="r1">[1]</a></sup> </li>
                <li>Benchmarks...</li>
            </ul>

            <h2>WHY</h2>
            <p>Mostly for fun and for the chance to work with tools that interested me. I've been interested in WASM for
                a while and have a lingering interest in compilers from my time in college. I also used this project as
                an opportunity to experiment with programming using LLMs, though that part was a middling success.</p>

            <p>Focusing on the project itself, there are a couple of advantages and disadvantages. The main advantage of
                compiling the regular expression comes from specializing the internal data structures and
                layout for the specific regex. The HOW section covers this compilation process in more detail.
                Another advantage is the WASM sandbox, which provides a strong security boundary. It makes me more confident that I
                won't inadvertently cause a vulnerability by attempting to read memory beyond the bounds of the haystack.</p>

            <p>The disadvantages are also tied to the WASM sandbox. Specifically, handling the haystack memory poses a performance problem.
                In order for the WASM functions to read the haystack memory, the embedding application needs to copy the haystack bytes into the WASM memory instance.
                Compare this to a normal regex library, which can often take a read-only view of the haystack directly, requiring no data copying.</p>

            <p>TODO include</p>
            <ul>
                <li>Disadvantage/advantage: Code bloat and pay for what you use (unicode)</li>
                <li>Better explanation of specializing data structures (talk about sparse set impl & minimizing the size
                    of state IDs)</li>
            </ul>

            <h2>HOW</h2>
            <p>This library is primarily built upon the excellent foundation of the <a
                    href="https://github.com/rust-lang/regex" target="_blank">Rust regex crates</a> and the
                work of @BurntSushi and other contributors. I used the <a
                    href="https://docs.rs/regex-automata/latest/regex_automata/"
                    target="_blank"><code>regex-automata</code>
                    crate</a> as the basis of my library, and did not have to re-implement regex parsing or conversion
                into non-deterministic automata (NFA).</p>

            <p>Internally, the WAHGEX library starts working after it gets an NFA from the <code>regex-automata</code>
                dependency. That NFA is essentially a list of <a
                    href="https://docs.rs/regex-automata/latest/regex_automata/nfa/thompson/enum.State.html"
                    target="_blank">states</a> such as "Look" (indicating a lookaround assertion), "Union" (representing an epsilon
                transition to multiple other states), or "Sparse" (transitioning to another state based on haystack
                matching), among others. Each state is uniquely identified by its position in the list of states, referred to as its
                "state ID".</p>

            <p></p>
        </article>
        <section>
            <p id="fn1"><a href="#r1">[1]</a> WASM engines have a different profile of optimization passes (if any),
                since they might assume that their input WASM module has come from another optimizing compiler like
                LLVM, or at least passed through an optimizer like <code>wasm-opt</code>. See <a
                    href="https://github.com/bytecodealliance/wasmtime/issues/4712"
                    target="_blank"><code>wasmtime#4712</code></a>
                for some discussion about which optimization passes are present in Wasmtime and which ones are present
                in the expected upstream.
            </p>
            <p id="fn2"><a href="#r2">[2]</a> This is a generalization. If you read the <a
                    href="https://docs.rs/regex-automata/latest/regex_automata/#available-regex-engines"
                    target="_blank">"Available
                    regex engines" section of regex-automata's docs</a>, you'll note that for each regular expression
                engine, there are many caveats, such as "only handles a subset of regexes" or "is generally slow."
            </p>
        </section>
    </main>
</body>

</html>